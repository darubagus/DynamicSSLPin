//
//  File.swift
//  
//
//  Created by Daru Bagus Dananjaya on 07/06/23.
//

import Foundation

public struct CertStoreConfig {
    
    /**
     - serviceUrl - parameter defining URL with a remote list of certificates. It is recommended that serviceUrl points to a different domain than you’re going to protect with pinning. See the FAQ section for more details.
     - pubKey - contains the public key counterpart to the private key, used for data signing. The Base64 formatted string is expected.
     - useChallenge - parameter that defines whether remote server requires challenge request header:
        use false in case the remote server provides a static data, generated by SSL Pinning Tool.
        FUTURE WORKS:
            use true in case you’re connecting to Mobile Utility Server or similar service. // FUTURE WORKS
     - expectedCommonNames - an optional array of strings, defining which domains you expect in certificate validation.
     - identifier - optional string identifier for scenarios, where multiple CertStore instances are used in the application
     - fallbackCertificatesData - optional hardcoded data for fallback fingerprints. See the next chapter of this document for details.
     - updateInterval - defines how often will CertStore update the fingerprints silently at the background. The default value is 1 week.
     - expirationThreshold - defines time window before the next certificate will expire. In this time window CertStore will try to update the list of fingerprints more often than usual. Default value is 2 weeks before the next expiration.
     - validationStrategy - defines the validation strategy for HTTPS connections initiated from the library itself. The .default value performs standard certificate chain validation provided by the operating system. Be aware that altering this option may put your application at risk. You should not ship your application to production with SSL validation turned off.
     */
    
// PROPERTIES
    public let serviceURL: URL
    
    public let pubKey: String
    
    public let useChallenge: Bool
    
//    optional
    public let identifier: String?
    
//    optional
    public let expectedCommonNames: [String]?
    
//   optional
    public let fallbackCertificate: Data?
    
/**
    Interval Configuration
 */
    public let updateInterval: TimeInterval
    
    public let expirationThreshold: TimeInterval
    
    public let validationStrategy: SSLValidationStrat
    
//    CONSTRUCTOR
    /**
            default value:
            update Interval: once every week
            Expiration threshold: once every two week
     */
    public init(serviceURL: URL, pubKey: String, useChallenge: Bool = false, identifier: String? = nil, expectedCommonNames: [String]? = nil, fallbackCertificate: Data? = nil, updateInterval: TimeInterval = 7*24*60*60, expirationThreshold: TimeInterval = 14*24*60*60, validationStrategy: SSLValidationStrat = .default) {
        self.serviceURL = serviceURL
        self.pubKey = pubKey
        self.useChallenge = useChallenge
        self.identifier = identifier
        self.expectedCommonNames = expectedCommonNames
        self.fallbackCertificate = fallbackCertificate
        self.updateInterval = updateInterval
        self.expirationThreshold = expirationThreshold
        self.validationStrategy = validationStrategy
    }
}

@available(iOS 13.0, *)
extension CertStoreConfig {
    public func validate(crypto: CryptoProvider) {
        
        if serviceURL.absoluteString.hasPrefix("http:") {
            print(" '.serviceURL' should point to 'https' endpoint.")
        }
        
        if validationStrategy == .noValidation {
            print(" .SSLValidationStrat.noValidation should not be used in production env")
        }

        if let fallbackCertData = fallbackCertificate {
            let decoder = JSONDecoder()
            decoder.dataDecodingStrategy = .base64
            decoder.dateDecodingStrategy = .secondsSince1970
            
            if let fallback = try? decoder.decode(Fingerprint.self, from: fallbackCertData) {
                for entry in fallback.fingerprints {
                    if let expectedCommonNameValidation = expectedCommonNames {
                        if !expectedCommonNameValidation.contains(entry.name) {
                            print("CertStore: certificate '\(entry.name)' in '.fallbackCertData' is issued for common name, which is not included in 'expectedCommonNames'.")
                        }
                    }
                    
                    // check if cert is already expired
                    if entry.expirationDate.timeIntervalSinceNow < 0 {
                        print("CertStore: certificate '\(entry.name)' in '.fallbackCertData' is already expired.")
                    }
                }
            } else {
                print("CertStore: '.fallbackCertData' contains invalid JSON.")
            }
        }
        
        // validate EC Public Key
        _ = crypto.importECPublicKey(pubKeyBase64: pubKey)
        // Handle negative time interval
        if expirationThreshold < 0 || updateInterval < 0 {
            Debug.fatalError("Invalid TimeInterval: Expiration Treshold or updateInterval")
        }
    }
}

